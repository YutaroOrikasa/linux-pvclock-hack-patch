# これは何？

kvm上で凖仮想化クロックを有効にしてlinuxゲストを実行した場合に、kvm凖仮想化クロックの内部状態にアクセスするためのカーネルパッチ&カーネルモジュールです。パッチを当てたカーネルをkvm上で動かし、ゲスト上でコンパイルしたカーネルモジュールをロードしてください。

kvmでlinuxゲストを実行した場合に、ホストをサスペンドさせてリジュームさせるとゲストがハングアップする現象を再現するために作成しました。

よく覚えていないソースコードを引っ張り出してきたので README.md に間違ったことが書いてあるかもしれません。

# ライセンス

GPLv2

# ビルドの仕方

1. linux-4.7のtarballをダウンロードして展開
2. diff.patchを当てる
3. linux-4.7カーネルをコンパイル
4. clockdebugディレクトリに移動しmakeを実行し、カーネルモジュールをコンパイル

# 使い方

1. コンパイルしたカーネルをkvm上で動かす、凖仮想化クロックを有効にする
2. clockdebugディレクトリに移動し insmod -f clockdebug.ko を実行

# APIs

- /sys/kernel/clockdebug/debug

読み出すとカーネル内部の凖仮想化クロックの内部状態(変数)等を返却。例:

```
$ cat /sys/kernel/clockdebug/debug
hv_clock(ptr): ffff88001ffd9000 pvti .version: 6 .system_time: 49201856 .tsc_to_system_mul: 3311327521 .tsc_shift: -1 .flags: 1 .tsc_timestamp: 696240294 rdtsc(): 320826378204
```

書き込むとカーネル内部の凖仮想化クロックの内部状態(変数)等がカーネルログに追記される。書き込んだバイト列は無視される。

- /sys/kernel/clockdebug/extra

10進数の数値(nとする)を書き込むと、凖仮想化クロックをnナノ秒分進める。0を書き込むまで進んだクロックは戻らない。

読み出すと現在何クロック進んでいるかを返却。

- /sys/kernel/clockdebug/trace

0以外を書き込むとkvm_clock_read関数のトレースを表示し、トレースを記録したバッファを消去する。
0を書き込むとトレースを記録したバッファを消去のみを行う。